{% extends "base.html" %}
{% block title %}Chat Application{% endblock %}
{% block body %}

<div class="container mt-4">
    <h2>Chat Application <small> - (<a href="/logout">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <div class="d-flex justify-content-between">
            <button onclick="sendMessage()" class="btn btn-primary">Send</button>
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let counter = 0
let iv


// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

//encrypt message
async function encryptMessage(message, encryption_key, iv){

    const ek = await window.crypto.subtle.importKey(
        "jwk",
        encryption_key,
        {
            name: "AES-GCM", 
            length: 256 
        },
        true,
        ["encrypt", "decrypt"],
    )
    return await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv,
        },
            ek,
            new TextEncoder().encode(message)
    )
}


// Send message function
async function sendMessage() {
    if (peer_id == -1) return; // Exit if no peer selected
    const message = document.getElementById('messageInput').value;
    console.log("Message", message)


    if (iv == undefined || iv == NaN) {
        iv = window.crypto.getRandomValues(new Uint8Array(12))
    }

    // `CHAT_KEY_USER_${myID}_to_USER_${peer_id}`

    // encrypt the message
    const aesKey = await window.crypto.subtle.importKey(
        "jwk",
        JSON.parse(localStorage.getItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`)),
        {
            name: "AES-GCM", 
            length: 256 
        },
        true,
        ["encrypt", "decrypt"],
    )
    console.log("AESKey", aesKey)
    console.log("iv", btoa(iv))
    
    const encryptedMessage = await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv,
            additionalData:  new TextEncoder().encode(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`),
        },
            aesKey,
            new TextEncoder().encode(message)
    )
    // console.log("Encrypted Message", encryptedMessage)
    console.log("Encrypted Message", btoa(new Uint8Array((encryptedMessage))))

    // HMAC the iv
    const HMACKey = await window.crypto.subtle.importKey(
        "jwk",
        JSON.parse(localStorage.getItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`)),
        {
            name: 'HMAC', 
            hash: 'SHA-256', 
            length: 256 
        },
        true,
        ["sign", "verify"],
    )
    
    console.log("HMACKey", HMACKey)
    const signature = await window.crypto.subtle.sign("HMAC", HMACKey, iv)
    
    const verifyvalue = await crypto.subtle.verify("HMAC", HMACKey, signature, iv)
    console.log("verifyvalue", verifyvalue)

    console.log("encryptedMessage", encryptedMessage)
    console.log("iv", iv)
    

    const payload = {
        receiver_id: peer_id,
        message_text: btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedMessage))),
        iv:   btoa(String.fromCharCode.apply(null, iv)),
        signature: btoa(String.fromCharCode.apply(null, new Uint8Array(signature))),
    };

    console.log(JSON.stringify(payload))

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}

async function generateECKeyPair() {

    console.log("---Generate a new EC key Pair---")

    const keyPair = await window.crypto.subtle.generateKey(
        { name: "ECDH", namedCurve: "P-384", },
        true,
        ["deriveKey", "deriveBits"],
    )

    const JWK_ECPublickey = await window.crypto.subtle.exportKey("jwk", keyPair.publicKey)
    const JWK_ECPrivatekey = await window.crypto.subtle.exportKey("jwk", keyPair.privateKey)
    console.log("JWK_ECPublickey", JSON.stringify(JWK_ECPublickey))
    console.log("JWK_ECPrivatekey", JSON.stringify(JWK_ECPrivatekey))
    console.log("---EC key Pair generated successfully---")

    localStorage.setItem("JWK_ECPublickey", JSON.stringify(JWK_ECPublickey))
    localStorage.setItem("JWK_ECPrivatekey", JSON.stringify(JWK_ECPrivatekey))
    console.log("---EC key Pair stored in localStorage---")

    return
    // return JSON.parse(localStorage.getItem("JWK_ECPublickey"))
}

// Send the public key to the server
async function sharedPublicKey() {

    const payload = {
        user_id: myID,
        public_key: localStorage.getItem("JWK_ECPublickey"),
    };

    console.log("---Share EC public key---")
    fetch('/sharedPublicKey', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Public Key sent:', data); // Log success message
    })
    .catch(error => {
        console.error('Error sending Public Key:', error); // Log any errors
    });

}

// If no JWK_ECkey
$(document).ready(function() {
    if (localStorage.getItem("JWK_ECPrivatekey") === null || localStorage.getItem("JWK_ECPublickey") === null ) {
        generateECKeyPair().then(() => {
            sharedPublicKey()
        })
    }
});

// Refresh Keys function placeholder
function refreshKeys() {
    // Placeholder for refresh functionality
    generateECKeyPair().then(() => {
        sharedPublicKey().then(() => {
            sendKeyChangedMessage()
        })
    })


}

async function sendKeyChangedMessage() {
    if (peer_id == -1) return; // Exit if no peer selected
    const message = "Keys changed";
    console.log("Message", message)


    if (iv == undefined || iv == NaN) {
        iv = window.crypto.getRandomValues(new Uint8Array(12))
    }

    // `CHAT_KEY_USER_${myID}_to_USER_${peer_id}`

    // encrypt the message
    const aesKey = await window.crypto.subtle.importKey(
        "jwk",
        JSON.parse(localStorage.getItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`)),
        {
            name: "AES-GCM", 
            length: 256 
        },
        true,
        ["encrypt", "decrypt"],
    )
    console.log("AESKey", aesKey)
    console.log("iv", btoa(iv))
    
    const encryptedMessage = await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv,
            additionalData:  new TextEncoder().encode(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`),
        },
            aesKey,
            new TextEncoder().encode(message)
    )
    // console.log("Encrypted Message", encryptedMessage)
    console.log("Encrypted Message", btoa(new Uint8Array((encryptedMessage))))

    // HMAC the iv
    const HMACKey = await window.crypto.subtle.importKey(
        "jwk",
        JSON.parse(localStorage.getItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`)),
        {
            name: 'HMAC', 
            hash: 'SHA-256', 
            length: 256 
        },
        true,
        ["sign", "verify"],
    )
    
    console.log("HMACKey", HMACKey)
    const signature = await window.crypto.subtle.sign("HMAC", HMACKey, iv)
    
    const verifyvalue = await crypto.subtle.verify("HMAC", HMACKey, signature, iv)
    console.log("verifyvalue", verifyvalue)

    console.log("encryptedMessage", encryptedMessage)
    console.log("iv", iv)
    

    const payload = {
        receiver_id: peer_id,
        message_text: btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedMessage))),
        iv:   btoa(String.fromCharCode.apply(null, iv)),
        signature: btoa(String.fromCharCode.apply(null, new Uint8Array(signature))),
    };

    console.log(JSON.stringify(payload))

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}


// Populate users function
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}


function fetchUserInfo() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = {
                    id: user[0],
                    username : user[1],
                    publicKey : user[2],
                } // Map user_id to username
                localStorage.setItem(`${user[0]}_PublicKey`, userInfo[user[0]].publicKey)// Store peer's public key
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching userInfo:', error));
}

// Fetch users from server
$(document).ready(function() {
    fetchUserInfo()
});

function bytesToHexString(bytes) {
    if (!bytes)
        return null;

    bytes = new Uint8Array(bytes);
    var hexBytes = [];

    for (var i = 0; i < bytes.length; ++i) {
        var byteString = bytes[i].toString(16);
        if (byteString.length < 2)
            byteString = "0" + byteString;
        hexBytes.push(byteString);
    }

    return hexBytes.join("");
}

async function keyExchange(peer_id) {
    // Check if EC key exchanged
    if(localStorage.getItem(`${peer_id}_PublicKey`) === null){
        // Preform key exchange
        console.log(`${peer_id} key not found!!!`)
    }

    // Compute Shared Secret
    console.log("My private key", localStorage.getItem("JWK_ECPrivatekey"))
    console.log(`${peer_id} ${userInfo[peer_id].username} public key`, userInfo[peer_id].publicKey)

    const my_privateKey = await window.crypto.subtle.importKey(
        "jwk",
        JSON.parse(localStorage.getItem("JWK_ECPrivatekey")),
        { name: "ECDH", namedCurve: "P-384", },
        true,
        ["deriveKey", "deriveBits"],
    )

    const peer_publicKey = await window.crypto.subtle.importKey(
        "jwk",
        JSON.parse(userInfo[peer_id].publicKey),
        { name: "ECDH", namedCurve: "P-384", },
        true,
        [],
    )

    const sharedSecret = await window.crypto.subtle.deriveBits(
        { name:"ECDH", public: peer_publicKey }, 
        my_privateKey, 
        384
    )
    
    console.log("sharedSecret", bytesToHexString(sharedSecret))
    
    
    const derivedKey = await window.crypto.subtle.importKey(
        "raw",
        sharedSecret,
        { name: "HKDF" },
        false,
        ["deriveKey"]
    )

    if (myID > peer_id) {
        deriveEncryptionKey(derivedKey, counter + 1, `CHAT_KEY_USER_${myID}_to_USER_${peer_id}`)
        .then((res) => {
            window.crypto.subtle.exportKey("jwk",res).then((e) => {
                console.log("---Derive two 256-bit AES-GCM encryption keys---")
                localStorage.setItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`, JSON.stringify(e))
            })
        })
        
        deriveEncryptionKey(derivedKey, counter + 2, `CHAT_KEY_USER_${peer_id}_to_USER_${myID}`)
        .then((res) => {
            window.crypto.subtle.exportKey("jwk",res).then((e) => {
                localStorage.setItem(`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`, JSON.stringify(e))
            })
        })

        deriveMACKey(derivedKey, counter + 3, `CHAT_MAC_USER_${myID}_to_USER_${peer_id}`)
        .then((res) => {
            window.crypto.subtle.exportKey("jwk",res).then((e) => {
                console.log("---Derive two 256-bit MAC keys---")
                localStorage.setItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`, JSON.stringify(e))
            })
        })

        deriveMACKey(derivedKey, counter + 4, `CHAT_MAC_USER_${peer_id}_to_USER_${myID}`)
        .then((res) => {
            window.crypto.subtle.exportKey("jwk",res).then((e) => {
                localStorage.setItem(`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`, JSON.stringify(e))
            })
        })
    } else {
        deriveEncryptionKey(derivedKey, counter + 1, `CHAT_KEY_USER_${peer_id}_to_USER_${myID}`)
        .then((res) => {
            window.crypto.subtle.exportKey("jwk",res).then((e) => {
                localStorage.setItem(`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`, JSON.stringify(e))
            })
        })

        deriveEncryptionKey(derivedKey, counter + 2, `CHAT_KEY_USER_${myID}_to_USER_${peer_id}`)
        .then((res) => {
            window.crypto.subtle.exportKey("jwk",res).then((e) => {
                console.log("---Derive two 256-bit AES-GCM encryption keys---")
                localStorage.setItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`, JSON.stringify(e))
            })
        })
        

        deriveMACKey(derivedKey, counter + 3, `CHAT_MAC_USER_${peer_id}_to_USER_${myID}`)
        .then((res) => {
            window.crypto.subtle.exportKey("jwk",res).then((e) => {
                localStorage.setItem(`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`, JSON.stringify(e))
            })
        })

        deriveMACKey(derivedKey, counter + 4, `CHAT_MAC_USER_${myID}_to_USER_${peer_id}`)
        .then((res) => {
            window.crypto.subtle.exportKey("jwk",res).then((e) => {
                console.log("---Derive two 256-bit MAC keys---")
                localStorage.setItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`, JSON.stringify(e))
            })
        })

    }
}



// Handle user selection change
document.getElementById('userList').addEventListener('change', event => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer

    // Perform key exchange if there is no shared key
    keyExchange(peer_id)
    // if (localStorage.getItem("ECKeyPair") == null) { 
    // }

    clearChatBox();
    lastMessageId = 0;
    fetchMessages(); // Fetch messages for the new selection
});

function deriveEncryptionKey(keyMaterial, salt, information) {
    return window.crypto.subtle.deriveKey(
        {
            name: "HKDF",
            salt: new TextEncoder().encode(salt),
            info: new Uint8Array(information),
            hash: "SHA-256",
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"],
    )
}

function deriveMACKey(keyMaterial, salt, information) {
    return window.crypto.subtle.deriveKey(
    {
        name: "HKDF",
        salt: new TextEncoder().encode(salt),
        info: new Uint8Array(information),
        hash: "SHA-256",
    },
        keyMaterial,
        {   
            name: 'HMAC', 
            hash: 'SHA-256', 
            length: 256 
        },
        true,
        ["sign", "verify"],
    );
}


// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

// Fetch messages from server
async function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        .then(response => response.json())
        .then(data => {
            // console.log("Peer->ME", JSON.parse(localStorage.getItem(`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`)))
            data.messages.forEach(message => {
                // console.log("message", message)
                displayMessage(message)
                lastMessageId = message.message_id;
            })
        })
        .catch(error => console.error('Error fetching messages:', error));
}

// Display a single message
async function displayMessage(message) {
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id].username || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id].username || `User ${message.receiver_id}`);

    const x = {
        message,
        ECPublicKey : localStorage.getItem("JWK_ECPublickey"),
        ECPrivateKey : localStorage.getItem("JWK_ECPrivatekey"),
        [`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`] : localStorage.getItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`),
        [`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`] : localStorage.getItem(`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`),
        [`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`] : localStorage.getItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`),
        [`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`] : localStorage.getItem(`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`),
    }
    if (localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`) === null){
        localStorage.setItem(`${myID}_${peer_id}_${message.message_id}`, JSON.stringify(x))
    }

    // console.log(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`)).message.iv)
    
    // var u8Decoded_iv = new Uint8Array(atob(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`)).message.iv).split("").map((c) => { return c.charCodeAt(0) }))
    // var u8Decoded_signIV = new Uint8Array(atob(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`)).message.signature).split("").map((c) => { return c.charCodeAt(0) }))
    // var u8Decoded_text = new Uint8Array(atob(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`)).message.message_text).split("").map((c) => { return c.charCodeAt(0) }))

    var u8Decoded_iv = new Uint8Array(atob(message.iv).split("").map((c) => { return c.charCodeAt(0) }))
    var u8Decoded_signIV = new Uint8Array(atob(message.signature).split("").map((c) => { return c.charCodeAt(0) }))
    var u8Decoded_text = new Uint8Array(atob(message.message_text).split("").map((c) => { return c.charCodeAt(0) }))

    if (sender === "me") { // I am sender
        const HMACKey = await crypto.subtle.importKey(
        "jwk",
        JSON.parse(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))[`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`]),
        { name: 'HMAC', hash: 'SHA-256', length: 256 },
        true,
        ["sign", "verify"],
        )

        const isFromMe = await window.crypto.subtle.verify(
            "HMAC", 
            HMACKey,
            u8Decoded_signIV, 
            u8Decoded_iv,
        )

        if (isFromMe) {

            const aesKey = await window.crypto.subtle.importKey(
                "jwk",
                JSON.parse(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))[`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`]),
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"],
                )
                
                console.log("aesKey", aesKey)
                
            const plaintext_arr = await window.crypto.subtle.decrypt(
                { 
                    name: "AES-GCM",
                    iv: u8Decoded_iv,
                    additionalData:  new TextEncoder().encode(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`),
                },
                aesKey, 
                u8Decoded_text
            )
                
            // console.log(new TextDecoder("utf-8").decode(plaintext_arr))
            const plaintext = new TextDecoder("utf-8").decode(plaintext_arr) 

            if (plaintext === "Keys changed") {
                messageElement.textContent = `${plaintext}`;
                messageElement.style.color = 'red'
                messagesContainer.appendChild(messageElement);
            } else {
                messageElement.textContent = `From ${sender} to ${receiver}: ${plaintext}`;
                messagesContainer.appendChild(messageElement);
            }

        } else {
            messageElement.textContent = `Warning: Message have been modified (Man in the middle attack) Or The Public Key have been update`;
            messagesContainer.appendChild(messageElement);
        }
                
    } else {

        const HMACKey = await crypto.subtle.importKey(
        "jwk",
        JSON.parse(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))[`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`]),
        // JSON.parse(localStorage.getItem(`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`)),
        { name: 'HMAC', hash: 'SHA-256', length: 256 },
        true,
        ["sign", "verify"],
        )

        const isFromPeer = await window.crypto.subtle.verify(
            "HMAC", 
            HMACKey,
            u8Decoded_signIV, 
            u8Decoded_iv,
        )

        if (isFromPeer){

            const aesKey = await window.crypto.subtle.importKey(
                "jwk",
                JSON.parse(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))[`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`]),
                // JSON.parse(localStorage.getItem(`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`)),
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"],
                )
                
                console.log("aesKey", aesKey)
                
            const plaintext_arr = await window.crypto.subtle.decrypt(
                { 
                    name: "AES-GCM",
                    iv: u8Decoded_iv,
                    additionalData:  new TextEncoder().encode(`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`),
                },
                aesKey, 
                u8Decoded_text
            )
                
            // console.log(new TextDecoder("utf-8").decode(plaintext_arr))
            const plaintext = new TextDecoder("utf-8").decode(plaintext_arr) 

            if (plaintext === "Keys changed") {
                messageElement.textContent = `${plaintext}`;
                messageElement.style.color = 'red'
                messagesContainer.appendChild(messageElement);
            } else {
                messageElement.textContent = `From ${sender} to ${receiver}: ${plaintext}`;
                messagesContainer.appendChild(messageElement);
            }
            
                
        } else {
            messageElement.textContent = `Warning: Message have been modified (Man in the middle attack) Or The Public Key have been update`;
            messagesContainer.appendChild(messageElement);
        }
    }

}

// Periodically fetch new messages every second
setInterval(fetchMessages, 10000);
// setInterval(fetchMessages, 1000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id].username+'?')) return; // Confirmation before erasing

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });
}

</script>
</body>

{% endblock %}
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de Carné de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->

