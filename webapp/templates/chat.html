{% extends "base.html" %}
{% block title %}Chat Application{% endblock %}
{% block body %}

<div id="mymodal" class="modal">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Set up new authenticator</h5>
                <button type="button" class="btn-close modalClose" data-bs-dismiss="modal"></button>
            </div>
            <div id="qrCodeDisplay" class="modal-body d-flex align-items-center flex-column">
                <h5>Step 1: Scan the QR-code to set up new authenticator for your next login</h5>
                <h7>(You can use <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en_US&pli=1" target="_blank">
                    Google Authenticator)
                </a></h7>
                
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary modalClose" data-bs-dismiss="modal">Done</button>
            </div>
        </div>
    </div>
</div>

<div class="chatApp-container">
    <div class="Apptitle p-2">
        <h4>Chat Application</h4>
    </div>
    <div class="toolsBar align-content-between d-flex">
        <div class="left-top d-flex justify-content-between">
            <button onclick="changeAuth()" id="changeAuthBtn" title="Change authenticator" class="btn">
                <i class="bi bi-stars"></i> Change Authenticator
            </button>
            <div>
                <a href="/logout" id="logoutBtn" class="btn">
                    <i class="bi bi-box-arrow-in-left"></i> Logout
                </a>
            </div>
        </div>
        <div class="right-top d-flex justify-content-end gap-2">
            <button onclick="refreshKeys()" id="refreshKeysBtn" class="btn" title="Refresh Key">
                <i class="bi bi-key-fill"></i>
            </button>
            <button onclick="eraseChat()" id="eraseBtn" class="btn" title="Erase chat">
                <i class="bi bi-trash3-fill"></i>
            </button>
        </div>
    </div>
    <div class="d-flex flex-grow-1 mb-2 overflow-hidden">
        <div class="left-chat w-25 h-100 overflow-y-scroll">
            <div class="container search-container">
                <input
                    class="form-control filter-users w-100 my-1"
                    placeholder="Search"
                />
            </div>
            <!-- User selection dropdown -->
            <select id="userList" class="form-control">
                <option value="-1" disabled selected><i>Choose a contact</i></option>
                <!-- User options populated here -->
            </select>
            <div id="userListDisplay">

            </div>
        </div>
        <div class="right-chat w-75">
            <div class="chat-box d-flex flex-column h-100">
                <!-- Chat messages container -->
                <div id="messages" class="flex-grow-1" style="border:1px solid #ccc; min-height:300px; overflow-y:scroll; padding:10px;"></div>
                <!-- Message input -->
                <textarea id="messageInput" class="form-control my-2 rounded-5" rows="1" style="width: 94%;" placeholder="Type a message..."></textarea>
                <div class="position-relative">
                    <button onclick="sendMessage()" id="sendMessageBtn" class="btn rounded-5 position-absolute">
                        <i class="bi bi-send-fill"></i>
                    </button>
                </div>

            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let counter = 0
let iv

$(".modalClose").on('click', function() {
    $("#mymodal").hide()
    $("#qrcode").remove()
    $("#twofa_key").remove()
})

function changeAuth() {
    if (!confirm('Are you sure you want to change authenticators?')) return; // Confirmation before erasing

    fetch(`/changeAuth`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ user_id: myID })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Authenticators changed successfully', data);
        
        const imgQR = document.createElement("img")
        imgQR.setAttribute("id", "qrcode")
        imgQR.setAttribute("class", "w-50 user-select-none")
        imgQR.setAttribute("src", data.qrCode)
        $("#qrCodeDisplay")[0].appendChild(imgQR)
        
        const secret_key = document.createElement("h5")
        secret_key.setAttribute("id", "twofa_key")
        secret_key.setAttribute("class", "mb-3")
        secret_key.textContent = `Your secret key: ${data.twofa_key}`
        $("#qrCodeDisplay")[0].appendChild(secret_key)

        $("#mymodal").show()
    })
    .catch(error => {
        console.error('Error request changing authenticators:', error);
    });
}


// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

//encrypt message
async function encryptMessage(message, encryption_key, iv){

    // encrypt the message
    const aesKey = await window.crypto.subtle.importKey(
        "jwk",
        encryption_key,
        {
            name: "AES-GCM", 
            length: 256 
        },
        true,
        ["encrypt", "decrypt"],
    )
    
    const encryptedMessage = await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv,
            additionalData:  new TextEncoder().encode(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`),
        },
            aesKey,
            new TextEncoder().encode(message)
    )

    return encryptedMessage
}

//decrypt message
async function decryptMessage(message, encryption_key, iv){

    const ek = await window.crypto.subtle.importKey(
        "jwk",
        encryption_key,
        {
            name: "AES-GCM", 
            length: 256 
        },
        true,
        ["encrypt", "decrypt"],
    )
    return await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv,
        },
            ek,
            new TextEncoder().encode(message)
    )
}


// Send message function
async function sendMessage() {
    if (peer_id == -1) return; // Exit if no peer selected
    const message = document.getElementById('messageInput').value;
    console.log("Message to be send: ", message)

    if (iv == undefined || iv == NaN) {
        iv = window.crypto.getRandomValues(new Uint8Array(12))
    } 
    else {
        iv[11] += 1 
    }

    // encrypt the message
    const encryptedMessage = await encryptMessage(
        message, 
        JSON.parse(atob(localStorage.getItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`))), 
        iv
    )


    // HMAC
    const HMACKey = await window.crypto.subtle.importKey(
        "jwk",
        JSON.parse(atob(localStorage.getItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`))),
        {
            name: 'HMAC', 
            hash: 'SHA-256', 
            length: 256 
        },
        true,
        ["sign", "verify"],
    )
    
    const signature = await window.crypto.subtle.sign("HMAC", HMACKey, iv)

    const payload = {
        receiver_id: peer_id,
        message_text: btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedMessage))),
        iv:   btoa(String.fromCharCode.apply(null, iv)),
        signature: btoa(String.fromCharCode.apply(null, new Uint8Array(signature))),
    };
    console.log("Payload", payload)

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}

async function generateECKeyPair() {

    console.log("---Generate a new EC key Pair---")

    const keyPair = await window.crypto.subtle.generateKey(
        { name: "ECDH", namedCurve: "P-384", },
        true,
        ["deriveKey", "deriveBits"],
    )

    const JWK_ECPublickey = await window.crypto.subtle.exportKey("jwk", keyPair.publicKey)
    const JWK_ECPrivatekey = await window.crypto.subtle.exportKey("jwk", keyPair.privateKey)
    console.log("JWK_ECPublickey", JSON.stringify(JWK_ECPublickey))
    console.log("JWK_ECPrivatekey", JSON.stringify(JWK_ECPrivatekey))
    console.log("---EC key Pair generated successfully---")

    localStorage.setItem("JWK_ECPublickey", btoa(JSON.stringify(JWK_ECPublickey)))
    localStorage.setItem("JWK_ECPrivatekey", btoa(JSON.stringify(JWK_ECPrivatekey)))
    console.log("---EC key Pair stored in localStorage---")

    return
}

// Send the public key to the server
async function sharedPublicKey() {

    const payload = {
        user_id: myID,
        public_key: localStorage.getItem("JWK_ECPublickey"),
    };

    console.log("---Share EC public key---")
    fetch('/sharedPublicKey', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Public Key sent:', data); // Log success message
    })
    .catch(error => {
        console.error('Error sending Public Key:', error); // Log any errors
    });

}

$(document).ready(function() {
    // Only generate for user first time log in
    if (localStorage.getItem("JWK_ECPrivatekey") === null || localStorage.getItem("JWK_ECPublickey") === null ) {// If no JWK_ECkey
        generateECKeyPair().then(() => {
            sharedPublicKey().then(() => {
                console.log("Keys generate successfully and sent to server!!!")
            })
        })
    }
});

// Refresh Keys function placeholder
function refreshKeys() {
    // Placeholder for refresh functionality
    generateECKeyPair().then(() => {
        sharedPublicKey().then(() => {
            sendKeyChangedMessage().then(() => {
                console.log("Keys have been updated!!!")
            })
        })
    })
}

async function sendKeyChangedMessage() {
    if (peer_id == -1) return; // Exit if no peer selected
    const message = "Keys changed!!!";
    console.log("Message", message)

    if (iv == undefined || iv == NaN) {
        iv = window.crypto.getRandomValues(new Uint8Array(12))
    }

    // encrypt the message
    const encryptedMessage = await encryptMessage(
        message, 
        JSON.parse(atob(localStorage.getItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`))), 
        iv
    )


    // HMAC
    const HMACKey = await window.crypto.subtle.importKey(
        "jwk",
        JSON.parse(atob(localStorage.getItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`))),
        {
            name: 'HMAC', 
            hash: 'SHA-256', 
            length: 256 
        },
        true,
        ["sign", "verify"],
    )
    
    const signature = await window.crypto.subtle.sign("HMAC", HMACKey, iv)

    const payload = {
        receiver_id: peer_id,
        message_text: btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedMessage))),
        iv:   btoa(String.fromCharCode.apply(null, iv)),
        signature: btoa(String.fromCharCode.apply(null, new Uint8Array(signature))),
    };

    console.log("Payload", payload)

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        // console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}

// Handle user selection change
document.getElementById('userList').addEventListener('change', event => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer

    console.log(`You are now communicating with: ${userInfo[peer_id].username}`)

    // Get peer's public key then Preform key exchange
    fetchUserPublicKey().then(() => {
        keyExchange(peer_id) // Perform key exchange
    })

    clearChatBox();
    lastMessageId = 0;
    fetchMessages(); // Fetch messages for the new selection
});

function selectUser(id) {
    const selected = document.getElementById('userList')

    selected.value = id
    selected.dispatchEvent(new Event('change'))
}

// Populate users function
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
        $("#userListDisplay").append(`
            <div class="user_block">
                <input type="radio" name="user_id" id="user_${user[0]}" onclick="selectUser(${user[0]})" />
                <label for="user_${user[0]}">${user[1]}</label>
            </div>
        `);
    });
}


function fetchUserPublicKey() {
    return new Promise((resolver, reject) => {
        fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = {
                    id: user[0],
                    username : user[1],
                    publicKey : user[2],
                } // Map user_id to username
                localStorage.setItem(`${user[0]}_PublicKey`, btoa(userInfo[user[0]].publicKey))// Store peer's public key
            });
            console.log("UserInfo", userInfo);
            resolver()
        })
        .catch(error => {
            console.error('Error fetching userInfo:', error)
            reject(error)
        });
    })
}


function fetchUserInfo() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = {
                    id: user[0],
                    username : user[1],
                    publicKey : user[2],
                } // Map user_id to username
                localStorage.setItem(`${user[0]}_PublicKey`, btoa(userInfo[user[0]].publicKey))// Store peer's public key
            });
            console.log("UserInfo", userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching userInfo:', error));
}

// Fetch users from server
$(document).ready(function() {
    fetchUserInfo()
});

async function computeSharedSecret(){

    console.log("My private key: ", localStorage.getItem("JWK_ECPrivatekey"))
    console.log(`${userInfo[peer_id].username} public key: `, userInfo[peer_id].publicKey)

    try {
        const my_privateKey = await window.crypto.subtle.importKey(
            "jwk",
            JSON.parse(atob(localStorage.getItem("JWK_ECPrivatekey"))),
            { name: "ECDH", namedCurve: "P-384", },
            true,
            ["deriveKey", "deriveBits"],
        )

        const peer_publicKey = await window.crypto.subtle.importKey(
            "jwk",
            JSON.parse(atob(userInfo[peer_id].publicKey)),
            { name: "ECDH", namedCurve: "P-384", },
            true,
            [],
        )

        const sharedSecret = await window.crypto.subtle.deriveBits(
            { name:"ECDH", public: peer_publicKey }, 
            my_privateKey, 
            384
        )
    
        return sharedSecret

    } catch (error) {
        generateECKeyPair().then(() => {
            sharedPublicKey().then(() => {
                console.log("Keys generate successfully and sent to server!!!")
                computeSharedSecret()
            })
        })
    }
}


// Perform EC key exchange
async function keyExchange(peer_id) {

        const sharedSecret = await computeSharedSecret()
        console.log("Shared Secret", btoa(sharedSecret))
        
        const derivedKey = await window.crypto.subtle.importKey(
            "raw",
            sharedSecret,
            { name: "HKDF" },
            false,
            ["deriveKey"]
        )

        if (myID > peer_id) {
            deriveEncryptionKey(derivedKey, counter + 1, `CHAT_KEY_USER_${myID}_to_USER_${peer_id}`)
            .then((res) => {
                window.crypto.subtle.exportKey("jwk",res).then((e) => {
                    console.log(`Derived 256-bit AES-GCM key successfully: ${btoa(JSON.stringify(e))}`)
                    localStorage.setItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`, btoa(JSON.stringify(e)))
                })
            })
            
            deriveEncryptionKey(derivedKey, counter + 2, `CHAT_KEY_USER_${peer_id}_to_USER_${myID}`)
            .then((res) => {
                window.crypto.subtle.exportKey("jwk",res).then((e) => {
                    console.log(`Derived 256-bit AES-GCM key successfully: ${btoa(JSON.stringify(e))}`)
                    localStorage.setItem(`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`, btoa(JSON.stringify(e)))
                })
            })

            deriveMACKey(derivedKey, counter + 3, `CHAT_MAC_USER_${myID}_to_USER_${peer_id}`)
            .then((res) => {
                window.crypto.subtle.exportKey("jwk",res).then((e) => {
                    console.log(`Derived 256-bit MAC key successfully: ${btoa(JSON.stringify(e))}`)
                    localStorage.setItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`, btoa(JSON.stringify(e)))
                })
            })

            deriveMACKey(derivedKey, counter + 4, `CHAT_MAC_USER_${peer_id}_to_USER_${myID}`)
            .then((res) => {
                window.crypto.subtle.exportKey("jwk",res).then((e) => {
                    console.log(`Derived 256-bit MAC key successfully: ${btoa(JSON.stringify(e))}`)
                    localStorage.setItem(`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`, btoa(JSON.stringify(e)))
                })
            })
        } else {
            deriveEncryptionKey(derivedKey, counter + 1, `CHAT_KEY_USER_${peer_id}_to_USER_${myID}`)
            .then((res) => {
                window.crypto.subtle.exportKey("jwk",res).then((e) => {
                    console.log(`Derived 256-bit AES-GCM key successfully: ${btoa(JSON.stringify(e))}`)
                    localStorage.setItem(`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`, btoa(JSON.stringify(e)))
                })
            })

            deriveEncryptionKey(derivedKey, counter + 2, `CHAT_KEY_USER_${myID}_to_USER_${peer_id}`)
            .then((res) => {
                window.crypto.subtle.exportKey("jwk",res).then((e) => {
                    console.log(`Derived 256-bit AES-GCM key successfully: ${btoa(JSON.stringify(e))}`)
                    localStorage.setItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`, btoa(JSON.stringify(e)))
                })
            })
            

            deriveMACKey(derivedKey, counter + 3, `CHAT_MAC_USER_${peer_id}_to_USER_${myID}`)
            .then((res) => {
                window.crypto.subtle.exportKey("jwk",res).then((e) => {
                    console.log(`Derived 256-bit MAC key successfully: ${btoa(JSON.stringify(e))}`)
                    localStorage.setItem(`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`, btoa(JSON.stringify(e)))
                })
            })

            deriveMACKey(derivedKey, counter + 4, `CHAT_MAC_USER_${myID}_to_USER_${peer_id}`)
            .then((res) => {
                window.crypto.subtle.exportKey("jwk",res).then((e) => {
                    console.log(`Derived 256-bit MAC key successfully: ${btoa(JSON.stringify(e))}`)
                    localStorage.setItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`, btoa(JSON.stringify(e)))
                })
            })
        }
    
}

function deriveEncryptionKey(keyMaterial, salt, information) {
    return window.crypto.subtle.deriveKey(
        {
            name: "HKDF",
            salt: new TextEncoder().encode(salt),
            info: new Uint8Array(information),
            hash: "SHA-256",
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"],
    )
}

function deriveMACKey(keyMaterial, salt, information) {
    return window.crypto.subtle.deriveKey(
    {
        name: "HKDF",
        salt: new TextEncoder().encode(salt),
        info: new Uint8Array(information),
        hash: "SHA-256",
    },
        keyMaterial,
        {   
            name: 'HMAC', 
            hash: 'SHA-256', 
            length: 256 
        },
        true,
        ["sign", "verify"],
    );
}


// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

// Fetch messages from server
async function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    
    try {
        const response = await fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        const data = await response.json()
        
        for (let message of data.messages) {
            console.log("message", message)
            await displayMessage(message)
            lastMessageId = message.message_id;
        }
    } catch (error) {
        console.log('Error fetching messages:', error)
    }
}

// Display a single message
async function displayMessage(message) {
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');
    messageElement.classList.add("d-flex")

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id].username || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id].username || `User ${message.receiver_id}`);

    const x = {
        message,
        ECPublicKey : localStorage.getItem("JWK_ECPublickey"),
        ECPrivateKey : localStorage.getItem("JWK_ECPrivatekey"),
        [`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`] : localStorage.getItem(`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`),
        [`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`] : localStorage.getItem(`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`),
        [`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`] : localStorage.getItem(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`),
        [`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`] : localStorage.getItem(`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`),
    }
    if (localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`) === null){
        localStorage.setItem(`${myID}_${peer_id}_${message.message_id}`, JSON.stringify(x))
    }

    var u8Decoded_iv = new Uint8Array(atob(message.iv).split("").map((c) => { return c.charCodeAt(0) }))
    var u8Decoded_signIV = new Uint8Array(atob(message.signature).split("").map((c) => { return c.charCodeAt(0) }))
    var u8Decoded_text = new Uint8Array(atob(message.message_text).split("").map((c) => { return c.charCodeAt(0) }))

    // check if iv > iv_pervious 
    if (localStorage.getItem(`${myID}_${peer_id}_${message.message_id - 1}`) != null) {
        // console.log(!JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id - 1}`))["message"].iv < JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))["message"].iv)
        if (!JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id - 1}`))["message"].iv < JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))["message"].iv) console.log("Replay attack: iv_i > iv_{i-1} ")
    }

    if (sender === "me") { // I am sender
        const HMACKey = await crypto.subtle.importKey(
            "jwk",
            JSON.parse(atob(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))[`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`])),
            { name: 'HMAC', hash: 'SHA-256', length: 256 },
            true,
            ["sign", "verify"],
        )

        const isFromMe = await window.crypto.subtle.verify(
            "HMAC", 
            HMACKey,
            u8Decoded_signIV, 
            u8Decoded_iv,
        )

        if (isFromMe) {

            const aesKey = await window.crypto.subtle.importKey(
                "jwk",
                JSON.parse(atob(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))[`CHAT_KEY_USER_${myID}_to_USER_${peer_id}`])),
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"],
                )
                
            const plaintext_arr = await window.crypto.subtle.decrypt(
                { 
                    name: "AES-GCM",
                    iv: u8Decoded_iv,
                    additionalData:  new TextEncoder().encode(`CHAT_MAC_USER_${myID}_to_USER_${peer_id}`),
                },
                aesKey, 
                u8Decoded_text
            )
                
            // console.log(new TextDecoder("utf-8").decode(plaintext_arr))
            const plaintext = new TextDecoder("utf-8").decode(plaintext_arr) 

            if (plaintext === "Keys changed!!!") {
                console.log(plaintext)
                messageElement.textContent = `Own keys changed`;
                messageElement.classList.add("keyChangedTag")
            } else {
                // messageElement.textContent = `From ${sender} to ${receiver}: ${plaintext}`;
                messageElement.textContent = plaintext;
                messageElement.classList.add("myTag")
            }

        } else {
            messageElement.textContent = `Warning: This message have been modified (Man in the middle attack) Or The Public Key have been update`;
            messageElement.classList.add("warningTag")
        }

        messageElement.setAttribute('id', message.message_id)
        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTo({top: messagesContainer.scrollHeight, behavior: 'smooth'})
    } else {

        const HMACKey = await crypto.subtle.importKey(
        "jwk",
        JSON.parse(atob(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))[`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`])),
        { name: 'HMAC', hash: 'SHA-256', length: 256 },
        true,
        ["sign", "verify"],
        )

        const isFromPeer = await window.crypto.subtle.verify(
            "HMAC", 
            HMACKey,
            u8Decoded_signIV, 
            u8Decoded_iv,
        )

        if (isFromPeer){

            const aesKey = await window.crypto.subtle.importKey(
                "jwk",
                JSON.parse(atob(JSON.parse(localStorage.getItem(`${myID}_${peer_id}_${message.message_id}`))[`CHAT_KEY_USER_${peer_id}_to_USER_${myID}`])),
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"],
                )
                
            const plaintext_arr = await window.crypto.subtle.decrypt(
                { 
                    name: "AES-GCM",
                    iv: u8Decoded_iv,
                    additionalData:  new TextEncoder().encode(`CHAT_MAC_USER_${peer_id}_to_USER_${myID}`),
                },
                aesKey, 
                u8Decoded_text
            )
                
            // console.log(new TextDecoder("utf-8").decode(plaintext_arr))
            const plaintext = new TextDecoder("utf-8").decode(plaintext_arr) 

            if (plaintext === "Keys changed!!!") {
                console.log(plaintext)
                messageElement.textContent = `${userInfo[peer_id].username}'s keys changed`;
                messageElement.classList.add("keyChangedTag")
            } else {
                // messageElement.textContent = `From ${sender} to ${receiver}: ${plaintext}`;
                messageElement.textContent = plaintext;
                messageElement.classList.add("peerTag")
            }
                
        } else {
            messageElement.textContent = `Warning: This message have been modified (Man in the middle attack) Or The Public Key have been update`;
            messageElement.classList.add("warningTag")
        }
        messageElement.setAttribute('id', message.message_id)
        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTo({top: messagesContainer.scrollHeight, behavior: 'smooth'})
    }
}

// Periodically fetch new messages every second
setInterval(fetchMessages, 1000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id].username+'?')) return; // Confirmation before erasing

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });
}

// Search user
document.querySelector('.filter-users').addEventListener('input', (e) => {
    const search = e.target.value;
    const users = document.querySelectorAll('.user_block');
    const searchLowerText = search.toLowerCase();

    for (const user of users) {
        // console.log(user)
        const lowerText = user.innerText.toLowerCase();
        if (lowerText.includes(searchLowerText)) {
            user.classList.remove('hide');
        } else {
            user.classList.add('hide');
        }
    }
})


</script>
</body>

{% endblock %}
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de Carné de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->

